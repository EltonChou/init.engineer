const PATTERN={FLUCTUATING:0,LARGE_SPIKE:1,DECREASING:2,SMALL_SPIKE:3},PROBABILITY_MATRIX={[PATTERN.FLUCTUATING]:{[PATTERN.FLUCTUATING]:.2,[PATTERN.LARGE_SPIKE]:.3,[PATTERN.DECREASING]:.15,[PATTERN.SMALL_SPIKE]:.35},[PATTERN.LARGE_SPIKE]:{[PATTERN.FLUCTUATING]:.5,[PATTERN.LARGE_SPIKE]:.05,[PATTERN.DECREASING]:.2,[PATTERN.SMALL_SPIKE]:.25},[PATTERN.DECREASING]:{[PATTERN.FLUCTUATING]:.25,[PATTERN.LARGE_SPIKE]:.45,[PATTERN.DECREASING]:.05,[PATTERN.SMALL_SPIKE]:.25},[PATTERN.SMALL_SPIKE]:{[PATTERN.FLUCTUATING]:.45,[PATTERN.LARGE_SPIKE]:.25,[PATTERN.DECREASING]:.15,[PATTERN.SMALL_SPIKE]:.15}},RATE_MULTIPLIER=1e4;function range_length(t){return t[1]-t[0]}function clamp(t,e,r){return Math.min(Math.max(t,e),r)}function range_intersect(t,e){return t[0]>e[1]||t[1]<e[0]?null:[Math.max(t[0],e[0]),Math.min(t[1],e[1])]}function range_intersect_length(t,e){return t[0]>e[1]||t[1]<e[0]?0:range_length(range_intersect(t,e))}function float_sum(t){let e=0,r=0;for(let i=0;i<t.length;i++){const a=t[i],n=e+a;Math.abs(e)>=Math.abs(a)?r+=e-n+a:r+=a-n+e,e=n}return e+r}function prefix_float_sum(t){const e=[[0,0]];let r=0,i=0;for(let a=0;a<t.length;a++){const n=t[a],_=r+n;Math.abs(r)>=Math.abs(n)?i+=r-_+n:i+=n-_+r,r=_,e.push([r,i])}return e}class PDF{constructor(t,e,r=!0){this.value_start=Math.floor(t),this.value_end=Math.ceil(e);const i=[t,e],a=range_length(i);if(this.prob=Array(this.value_end-this.value_start),r)for(let t=0;t<this.prob.length;t++)this.prob[t]=range_intersect_length(this.range_of(t),i)/a}range_of(t){return[this.value_start+t,this.value_start+t+1]}min_value(){return this.value_start}max_value(){return this.value_end}normalize(){const t=float_sum(this.prob);for(let e=0;e<this.prob.length;e++)this.prob[e]/=t;return t}range_limit(t){let[e,r]=t;if((e=Math.max(e,this.min_value()))>=(r=Math.min(r,this.max_value())))return this.value_start=this.value_end=0,this.prob=[],0;e=Math.floor(e),r=Math.ceil(r);const i=e-this.value_start,a=r-this.value_start;for(let e=i;e<a;e++)this.prob[e]*=range_intersect_length(this.range_of(e),t);return this.prob=this.prob.slice(i,a),this.value_start=e,this.value_end=r,this.normalize()}decay(t,e){t=Math.round(t),e=Math.round(e);const r=prefix_float_sum(this.prob),i=this.prob.length,a=e-t,n=Array(this.prob.length+a);for(let t=0;t<n.length;t++){const e=Math.max(0,t-a),_=Math.min(i-1,t),s=[r[_+1][0],r[_+1][1],-r[e][0],-r[e][1]];e===t-a&&s.push(-this.prob[e]/2),_===t&&s.push(-this.prob[_]/2),n[t]=float_sum(s)/a}this.prob=n,this.value_start-=e,this.value_end-=t}}class Predictor{constructor(t,e,r){this.fudge_factor=0,this.prices=t,this.first_buy=e,this.previous_pattern=r}intceil(t){return Math.trunc(t+.99999)}minimum_rate_from_given_and_base(t,e){return RATE_MULTIPLIER*(t-.99999)/e}maximum_rate_from_given_and_base(t,e){return RATE_MULTIPLIER*(t+1e-5)/e}rate_range_from_given_and_base(t,e){return[this.minimum_rate_from_given_and_base(t,e),this.maximum_rate_from_given_and_base(t,e)]}get_price(t,e){return this.intceil(t*e/RATE_MULTIPLIER)}*multiply_generator_probability(t,e){for(const r of t)yield{...r,probability:r.probability*e}}generate_individual_random_price(t,e,r,i,a,n){a*=RATE_MULTIPLIER,n*=RATE_MULTIPLIER;const _=t[0],s=[a,n];let o=1;for(let l=r;l<r+i;l++){let r=this.get_price(a,_),i=this.get_price(n,_);if(!isNaN(t[l])){if(t[l]<r-this.fudge_factor||t[l]>i+this.fudge_factor)return 0;o*=range_intersect_length(s,this.rate_range_from_given_and_base(clamp(t[l],r,i),_))/range_length(s),r=t[l],i=t[l]}e.push({min:r,max:i})}return o}generate_decreasing_random_price(t,e,r,i,a,n,_,s){a*=RATE_MULTIPLIER,n*=RATE_MULTIPLIER,_*=RATE_MULTIPLIER,s*=RATE_MULTIPLIER;const o=t[0];let l=new PDF(a,n),h=1;for(let a=r;a<r+i;a++){let r=this.get_price(l.min_value(),o),i=this.get_price(l.max_value(),o);if(!isNaN(t[a])){if(t[a]<r-this.fudge_factor||t[a]>i+this.fudge_factor)return 0;const e=this.rate_range_from_given_and_base(clamp(t[a],r,i),o);if(0==(h*=l.range_limit(e)))return 0;r=t[a],i=t[a]}e.push({min:r,max:i}),l.decay(_,s)}return h}generate_peak_price(t,e,r,i,a){i*=RATE_MULTIPLIER,a*=RATE_MULTIPLIER;const n=t[0];let _=1,s=[i,a];const o=t[r+1];if(!isNaN(o)){const t=this.get_price(i,n),e=this.get_price(a,n);if(o<t-this.fudge_factor||o>e+this.fudge_factor)return 0;const r=this.rate_range_from_given_and_base(clamp(o,t,e),n);if(0==(_*=range_intersect_length(s,r)/range_length(s)))return 0;s=range_intersect(s,r)}const l=t[r],h=t[r+2];for(const t of[l,h]){if(isNaN(t))continue;const e=this.get_price(i,n)-1,r=this.get_price(s[1],n)-1;if(t<e-this.fudge_factor||t>r+this.fudge_factor)return 0;const a=this.rate_range_from_given_and_base(clamp(t,e,r)+1,n),o=(t,e)=>t<=0?0:e<t?e:t-t*(Math.log(t)-Math.log(e)),[l,h]=s,p=i,c=l-p,g=h-p,u=t=>(o(t-p,g)-o(t-p,c))/(g-c);if(0==(_*=u(a[1])-u(a[0])))return 0}let p=this.get_price(i,n)-1,c=this.get_price(a,n)-1;return isNaN(t[r])||(p=t[r],c=t[r]),e.push({min:p,max:c}),p=e[r].min,c=this.get_price(a,n),isNaN(t[r+1])||(p=t[r+1],c=t[r+1]),e.push({min:p,max:c}),p=this.get_price(i,n)-1,c=e[r+1].max-1,isNaN(t[r+2])||(p=t[r+2],c=t[r+2]),e.push({min:p,max:c}),_}*generate_pattern_0_with_lengths(t,e,r,i,a,n){const _=t[0],s=[{min:_,max:_},{min:_,max:_}];let o=1;if(0==(o*=this.generate_individual_random_price(t,s,2,e,.9,1.4)))return;if(0==(o*=this.generate_decreasing_random_price(t,s,2+e,r,.6,.8,.04,.1)))return;if(0==(o*=this.generate_individual_random_price(t,s,2+e+r,i,.9,1.4)))return;if(0==(o*=this.generate_decreasing_random_price(t,s,2+e+r+i,a,.6,.8,.04,.1)))return;if(2+e+r+i+a+n!=14)throw new Error("Phase lengths don't add up");const l=2+e+r+i+a;0!=(o*=this.generate_individual_random_price(t,s,l,14-l,.9,1.4))&&(yield{pattern_description:"patterns.fluctuating",pattern_number:0,prices:s,probability:o})}*generate_pattern_0(t){for(var e=2;e<4;e++)for(var r=0;r<7;r++)for(var i=0;i<7-r-1+1;i++)yield*this.multiply_generator_probability(this.generate_pattern_0_with_lengths(t,r,e,7-r-i,5-e,i),.5/7/(7-r))}*generate_pattern_1_with_peak(t,e){const r=t[0],i=[{min:r,max:r},{min:r,max:r}];let a=1;if(0==(a*=this.generate_decreasing_random_price(t,i,2,e-2,.85,.9,.03,.05)))return;let n=[.9,1.4,2,1.4,.9,.4,.4,.4,.4,.4,.4],_=[1.4,2,6,2,1.4,.9,.9,.9,.9,.9,.9];for(let r=e;r<14;r++)if(0==(a*=this.generate_individual_random_price(t,i,r,1,n[r-e],_[r-e])))return;yield{pattern_description:"patterns.large-spike",pattern_number:1,prices:i,probability:a}}*generate_pattern_1(t){for(var e=3;e<10;e++)yield*this.multiply_generator_probability(this.generate_pattern_1_with_peak(t,e),1/7)}*generate_pattern_2(t){const e=t[0],r=[{min:e,max:e},{min:e,max:e}];let i=1;0!=(i*=this.generate_decreasing_random_price(t,r,2,12,.85,.9,.03,.05))&&(yield{pattern_description:"patterns.decreasing",pattern_number:2,prices:r,probability:i})}*generate_pattern_3_with_peak(t,e){const r=t[0],i=[{min:r,max:r},{min:r,max:r}];let a=1;0!=(a*=this.generate_decreasing_random_price(t,i,2,e-2,.4,.9,.03,.05))&&0!=(a*=this.generate_individual_random_price(t,i,e,2,.9,1.4))&&0!=(a*=this.generate_peak_price(t,i,e+2,1.4,2))&&(e+5<14&&0==(a*=this.generate_decreasing_random_price(t,i,e+5,14-(e+5),.4,.9,.03,.05))||(yield{pattern_description:"patterns.small-spike",pattern_number:3,prices:i,probability:a}))}*generate_pattern_3(t){for(let e=2;e<10;e++)yield*this.multiply_generator_probability(this.generate_pattern_3_with_peak(t,e),1/8)}get_transition_probability(t){return void 0===t||Number.isNaN(t)||null===t||t<0||t>3?[4530/13082,3236/13082,1931/13082,3385/13082]:PROBABILITY_MATRIX[t]}*generate_all_patterns(t,e){const r=[this.generate_pattern_0,this.generate_pattern_1,this.generate_pattern_2,this.generate_pattern_3],i=this.get_transition_probability(e);for(let e=0;e<4;e++)yield*this.multiply_generator_probability(r[e].bind(this)(t),i[e])}*generate_possibilities(t,e,r){if(e||isNaN(t[0]))for(var i=90;i<=110;i++){const a=t.slice();a[0]=a[1]=i,e?yield*this.generate_pattern_3(a):yield*this.generate_all_patterns(a,r)}else yield*this.generate_all_patterns(t,r)}analyze_possibilities(){const t=this.prices,e=this.first_buy,r=this.previous_pattern;let i=[];for(let a=0;a<6;a++)if(this.fudge_factor=a,(i=Array.from(this.generate_possibilities(t,e,r))).length>0){console.log("Generated possibilities using fudge factor %d: ",a,i);break}const a=i.reduce((t,e)=>t+e.probability,0);for(const t of i)t.probability/=a;for(let t of i){var n=[],_=[];for(let e of t.prices.slice(2))e.min!==e.max?(n.push(e.min),_.push(e.max)):(n=[],_=[]);n.length||_.length||(n.push(t.prices[t.prices.length-1].min),_.push(t.prices[t.prices.length-1].max)),t.weekGuaranteedMinimum=Math.max(...n),t.weekMax=Math.max(..._)}let s={};for(let t of[0,1,2,3])s[t]=i.filter(e=>e.pattern_number==t).map(t=>t.probability).reduce((t,e)=>t+e,0);for(let t of i)t.category_total_probability=s[t.pattern_number];i.sort((t,e)=>e.category_total_probability-t.category_total_probability||e.probability-t.probability);let o=[];for(let t=0;t<14;t++){const e={min:999,max:0};for(let r of i)r.prices[t].min<e.min&&(e.min=r.prices[t].min),r.prices[t].max>e.max&&(e.max=r.prices[t].max);o.push(e)}return i.unshift({pattern_description:"patterns.all",pattern_number:4,prices:o,weekGuaranteedMinimum:Math.min(...i.map(t=>t.weekGuaranteedMinimum)),weekMax:Math.max(...i.map(t=>t.weekMax))}),i}}
